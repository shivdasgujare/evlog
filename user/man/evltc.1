.\" This manpage has been automatically generated by docbook2man
.\" from a DocBook document.  This tool can be found at:
.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
.\" Please send any bug reports, improvements, comments, patches, 
.\" etc. to Steve Cheng <steve@ggi-project.org>.
.TH "EVLTC" "1" "6 December 2002" "" ""
.SH NAME
evltc \- Compile formatting templates
.SH SYNOPSIS
.fi
\fBevltc\fR \fB  \fIsourcefile\fB  [\fB-f | --func]  [-n | --noto]   
.nf
.fi
        [-c | --cpp]  [cpp_options] \fR

or

\fBevltc\fR \fB \fIbinfile.to\fR
.nf
.SH "DESCRIPTION"
.PP
The \fBevltc\fR command reads the
formatting template specification(s) in
\fIsourcefile\fR and creates a binary
template file for each specification.
\fIsourcefile\fR may not define two templates with
the same \fIevent_type\fR, even if they are for  
different facilities.
Binary files are created
in the directory where \fIsourcefile\fR
resides.
.PP
If the name of the specified file ends in \fI.to\fR, it is assumed to be a
binary template file.  It is read, and if it contains an event-record
template, the corresponding sample call to the \fBevl_log_write()\fR function
is printed, as with \fB-f\fR.  In this case, the \fB-f\fR and \fB-n\fR options (if
specified) are ignored, and any cpp-related options are flagged as
errors.
.PP
The binary file for an event-record template is named
\fIeventtype.to\fR,
where
\fIeventtype\fR is the hexadecimal
event type.
For a facility's default template, the binary file is named
\fIdefault.to\fR.
.PP
The binary file for a struct template is named
\fIstructname.to\fR.
.PP
If the source file contains any errors, no binary files
are produced, and error messages are written to stderr.
.PP
The algorithm for finding a struct template that is referenced by
another template is as follows:
.fi

(1) The struct_path from the import statement is converted into a relative pathname by
replacing all periods with slashes and appending .to.  For example,
gui.graphics.point becomes gui/graphics/point.to. 

(2) This relative pathname is applied to each of the following directories in turn until a
file is found: 
 (a) the directory in which the current template source file resides. 
 (b) the directories specified in the EVLTMPLPATH environment variable (a
colon-delimited list of directories).  If the EVLTMPLPATH environment
variable is not defined, the directories
/var/evlog/templates/$LANG and /var/evlog/templates
are searched, in that order. 
 
(3) The selected template file is read into memory if it is not already there. 

It is neither necessary nor permitted to import a template with the same name
as one previously defined in the current template source file, unless the
imported template is from a different directory.  See Example 3 (below).
.nf
.SH "OPTIONS"
.TP
\fB-f, --func\fR
When this option is specified, a sample call to the
evl_log_write() function is created.
Such a call could be used to log an event record whose 
format matches the template.  
.TP
\fB-n, --noto\fR
Compile the template source and report errors as appropriate, but
do not write out the binary template file(s).
.TP
\fB-c, --cpp\fR
Run \fIsourcefile\fR through the C preprocessor, /lib/cpp, and
compile the result.  The contents of \fIsourcefile\fR are unchanged.
.TP
\fB-D\fR  \fImacro[=defn]\fR
Passed to the C preprocessor.  Implies -c.
.TP
\fB-U\fR  \fImacro\fR
Passed to the C preprocessor.  Implies -c.
.TP              
\fB-I\fR  \fIdir\fR
Passed to the C preprocessor.  Implies -c.
.SH "EXAMPLES"

\fBExample 1.\fR
.nf

Suppose the file \fIVolMgr.t\fR contains the following text.

.nf
/* Start of first template */
struct sourceInfo;
attributes {
      string sourceFile;  int lineNumber;
}
format
%sourceFile%: %lineNumber%:
END

/* Start of second template */
facility "VolMgr"; event_type 0x456;
attributes {
      struct sourceInfo srcInfo;
      string volumeName;  ulong vsize;
}
format
%srcInfo%
Created volume %volumeName% with size %vsize%.
END

/* Start of third template */
facility "VolMgr"; event_type 0x789;
attributes {
      struct sourceInfo srcInfo;
      string diskName;  string diskGroup;
}
format
%srcInfo%
Added disk %diskName% to disk group %diskGroup%.
.fi
.PP

The command
.nf
    evltc VolMgr.t
.fi
will create three files: \fIsourceInfo.to\fR,
\fI0x456.to\fR, and \fI0x789.to\fR in the same
directory as \fIVolMgr.t\fR.


\fBExample 2.\fR
.nf

Given the following formatting template, stored
in the file SCSIadap.t:
 
/* HEADER SECTION */
   facility "LOCAL1";
   event_type 0x3115; 
/* CONST-ATTRIBUTES SECTION */
   const {
         string  repair_action = "Replace SCSI adapter";
   }

/* RECORD-ATTRIBUTES SECTION */
   attributes {
        char    unit_ser_no[8]        "%s";
        ushort  lun                   "%u";
        char    sense_bytes[12]       "%t";
   /* For the next attribute, the various segments of 
    * the format string are automatically concatenated
    * into a single string.
    */
        uchar  recovery_stat  "%b/0x40/INTERFACE_WAS_RESET/"
                              "0x20/RECOVERY_ACTION_STARTED/"
                              "0x10/RECOVERY_ACTION_FAILED/";
   /* The final attribute specification says to display the
    * rest of the bytes in dump format.
    */
   char            extra_data[_R_]     "%t";
   }
   
/* FORMATTING SECTION */
   format
   SCSI interface error: Adapter Ser Num/LUN = %unit_ser_no%/%lun%
            
   \tRecovery Status: %recovery_stat%
   \tSense Bytes:
   %sense_bytes%
                 
   \tRecommended repair action:
   \t\t%repair_action%                 
            
   %extra_data%
 
 
The command
       evltc SCSIadap.t -f
will create the file 0x3115.to in the same directory 
as \fISCSIadap.t\fR and the following will be displayed 
(on stdout):
       
       evl_log_write(LOG_LOCAL1, 12565 /* 0x3115 */, severity, flags,
                  "char[]", 8, unit_ser_no,
                  "ushort", lun,
                  "char[]", 12, sense_bytes,
                  "uchar", recovery_stat,
                  "char[]", _R_, extra_data,
                  "endofdata");
            
       


\fBExample 3.\fR
.nf

These examples illustrate the importing of templates.

The following sequence of statements is legal:

struct statusRegister;
  [definition of struct statusRegister's attributes and format]
END
import chipSet.fpu.statusRegister; /* LEGAL [unless chipSet/fpu
                                   specifies the current directory] */
import chipSet.fpu.dataRegisters;
...
attributes {
  struct statusRegister cpuStatus;      /* refers to struct
                                        defined in this file */
  struct chipSet.fpu.statusRegister fpuStatus;
  struct dataRegisters dataRegs;
 }

However, the following example has an illegal sequence of statements:

struct statusRegister;
  [definition of struct statusRegister's attributes and format]
END
import statusRegister;   /* ILLEGAL */



.fi
.SH "FILES"
.PP
\fI/var/evlog/templates\fR -  Formatting
template repository
